---
title: MySQL底层Log系统
author: Noah
date: 2024/06/29 16:55
categories: 

 - MySQL进阶
tags:
  - MySQL
  - MySQL进阶
  - 事务
  - 并发事务
---

# MySQL 底层 Log 系统

[[toc]]

## MySQL 的日志系统概述

1. **重做日志(Redo Log):** `InnoDB` 存储引擎特有的日志，用于保证事务的持久性(Durability)。当事务提交时，数据首先写入 Redo Log ，然后再更新到实际的数据文件中。如果系统崩溃，重启后可以通过 Redo Log 恢复已提交的事务。
2. **回滚日志(Undo Log):** `InnoDB` 存储引擎特有的日志，用于支持事务的原子性(Atomicity)和隔离性(Isolation)。当事务执行修改操作时，Undo Log 记录修改前的数据副本。如果事务回滚，可以通过Undo Log 恢复数据到修改前的状态。此外，Undo Log 还用于支持多版本并发控制(MVCC)，以实现一致性读取。
3. **二进制日志(Binary Log，简称bin log):** 记录所有对数据库进行了修改的SQL语句，包括增、删、改。 bin log 主要用于复制和数据恢复。
4. **中继日志(Realy Log):** 从主节点的 bin log 传到从节点后，被写到 realy log 主节点一般不需要开启该日志
5. **错误日志(Error Log):** 记录 `MySQL` 服务器启动、运行或停止过程中的错误、警告和注意事项。
6. **慢查询日志(Slow Query Log):** 记录执行时间超过指定阈值的查询语句，用于优化数据库性能。
7. **通用查询日志(General Query Log):** 记录MySQL服务器接收到的所有SQL语句，常用于调试。

![](https://raw.githubusercontent.com/Noah2Y/img/main/blog/20240629173903.png)

## Redo Log 详解

Redo Log  是 `MySQL` 中 `InnoDB` 存储引擎实现事务持久化(Durability)的关键组件。它确保了系统在发生崩溃时，能够通过日志恢复已提交的事务，保持数据的一致性和完整性。

### Redo Log 的作用

1. **持久化保障:** 确保事务修改提交后不会因系统崩溃而丢失。
2. **崩溃恢复:** 系统崩溃后，可以通过 Redo Log 恢复已提交的事务。
3. **提高性能:** 通过先写日志再写数据也的方式，减少了频繁的磁盘I/O操作。

### Redo Log 的结构

- **Redo Log Buffer:** 位于内存中，用于暂存 Redo Log 的内容。事务在执行过程中会将修改操作记录到 `Redo Log Buffer` 中。

- **Redo Log 文件:**  位于磁盘中，`Redo Log Buffer` 中的内容会周期性地刷新到 Redo Log 文件中。 通常有两个或多个文件组成。

### Redo Log 的工作原理

1. **记录修改:** 当事务执行修改操作时，会将修改记录写入 `Redo Log Buffer` 中。
2. **日志刷新:** 当事务提交时， `InnoDB` 存储引擎会将 `Redo Log Buffer` 中的内容刷新到 Redo Log 文件中(称为“刷盘”)
3. **事务提交:** 确保 Redo Log文件中的内容已经写入磁盘后，事务才会正则提交。
4. **循环写:** Redo Log 文件组以循环方式使用，当写到文件末尾时，会回到文件开头继续写，但会确保不覆盖未提交的事务。

## Undo Log 详解

Undo Log 是 `MySQL `中 `InnoDB` 存储引擎实现事务原子性和隔离性的关键组件。它记录了事务执行过程中数据修改前的状态，用于在事务回滚时恢复数据，同时在多版本并发控制，即 `MVCC` ，中也起到了总要的作用。

### Undo Log 的作用

1. **支持事务回滚:** 当事务执行过程中出现错误或显示回滚时，通过 Undo Log 恢复数据到修改前的状态。
2. **实现MVCC:** 多版本并发控制(MVCC)允许事务在读取数据时不阻塞写操作，通过保存数据的多个版本，确保读取操作看到的是一致的快做。

### Undo Log 的结构

Undo Log 由多个 Undo Log  段组成，每个Undo Log  段记录一组相关的修改操作。主要包括以下几种类型：

1. **插入日志:** 记录插入操作，事务回滚时会删除这些插入的数据。
2. **更新日志:** 记录更新操作，事务回滚时会将数据恢复到更新前的状态。
3. **删除日志:** 记录删除操作，事务回滚时会恢复被删除的数据。

### Undo Log 的工作原理

1. **记录修改前的状态:** 当事务执行插入、删除或更新操作时，会生成该操作相反的操作记录在 Undo Log 中.
2. **链式结构:** Undo Log 记录按照事务的执行顺序形成链式结构，每条记录包含一个指向前一条记录的指针(称为“回滚段”)。
3. **事务提交后保留:** 即使事务提交后， Undo Log 记录仍然保留，用于支持 `MVCC` 读取操作。
4. **清理和回收:** 当不再有事务需要访问 Undo Log记录时，这些记录会被清理和回收，以释放空间

## Binary Log 详解

bin log 是MySQL中记录所有对数据库进行更改的事件日志文件，它用于主从复制和数据恢复。

### bin log 的作用

1. **复制:** 在主从复制中，主库将 bin log 传给从库，从库根据 bin log 操作，实现数据同步。
2. **数据恢复:** 通过 bin log ，可以将数据库恢复到某个时间点或某个特定的事务状态。

### bin log 的结构

bin log 由一系列二进制文件组成，每个文件记录了一段时间内所有事务的更改操作。这些文件按照顺序编号，形成一个日志文件组。每个 bin log 文件由多个事件组成，每个事件记录了一次数据更改操作。

### bin log 的工作原理

1. **事务开始:** 在事务开始时，`MySQL` 会生成一个事务 ID，并为该事物记录日志。
2. **记录修改:** 在事务执行过程中，每个修改操作都会生成一个事件并记录到 `bin log buffer` 中 
3. **提交事务:** 当事务提交时，`bin log buffer`  中的内容会被刷新到 bin log 文件中，确保事务的持久性。
4. **日志轮转:** 当 bin log 文件达到指定大小时，会生成一个新的 bin log 文件，继续记录后续的操作。

## 拓展

### 多版本并发控制(MVCC)

`MVCC` (Multi-Version Concurrency Control, 多版本并发控制) 是一种用于管理数据库并发访问的方法。它允许多个事务并发执行，而不会相互阻塞，从而提高系统的吞吐量和性能。`MVCC` 通过维护数据的多个版本，使得读取操作与写入操作可以同时进行，避免了传统锁机制带来的性能瓶颈。

#### MVCC 的基本原理

 `MVCC` 通过为每个数据行维护多个版本的副本，并在每个事务开始时生成一个时间戳(事务ID)，来实现并发控制，事务在读取数据时，依据时间戳决定读取那个版本的数据，从而实现一致性读取。

#### MVCC 的主要机制

1. **数据版本管理:** 每次数据修改操作都会生成一个新的数据版本，旧版本不会立即删除，而是保留用于并发事务读取。
2. **事务ID:** 每个事务开始时都会获取到一个唯一的事务 ID， 事务 ID 用于标识事务的时间顺序。
3. **隐式列:** `InnoDB` 存储引擎为每行属性添加两个隐式列：`trx_id` 和 `roll_pointer` 。`trx_id` 表示最后修改该行的事务ID，`roll_pointer` 指向 Undo Log 记录，用于恢复数据到之前的版本。

#### MVCC的工作原理

>读操作
>
>>快照读：读取数据时，事务会更具自己的事务ID读取数据的一个快照版本，而不是直接读取当前最新的数。这种读取不会阻塞其他写操作。
>
>>一致性读取：通过事务ID和数据行的 `trx_id` ，事务会选择一个在事务开始前生成的数据版本进行读取，确保一致性。
>
>写操作
>
>> 写操作：写操作会生成新的数据版本，同时更新数据行的 `trx_id` 和 `roll_pointer` 。
>>
>> 提交事务：事务提交时，新的数据版本会成为最新版本，旧版本任然保留用于其他未提交的事务读取。
>>
>> 回滚操作：如果事务需要回滚，通过 `roll_pointer` 和Undo Log 恢复数据到修改前的状态。

#### MVCC 的优缺点

**优点：**

1. **高并发性：** 读操作无需加锁，不会阻塞写操作，提高了系统的并发性能。

2. **一致性读取：** 事务读取的数据是一致的快照版本，避免了脏读、不可重复读等问题。

3. **性能优化：** 减少了锁争用，提高了数据库整体性能

**缺点：**

1. **空间开销：** 保留多个版本的副本和Undo Log记录会占用额外的存储空间。
2. **复杂性：** 实现和回复MVCC机制相对复杂，可能会增加系统的开发和维护成本。